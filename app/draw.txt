

function draw() {
    var t = canvas.node().getContext("2d");
    t.save(), t.clearRect(0, 0, width, height);
    for (var i = 0; i < points.length; ++i) {
        var n = points[i];
        t.fillStyle = n.color, t.fillRect(n.x, n.y, pointWidth, pointWidth)
    }
    t.restore()
}

function animate(t) {
    points.forEach(function(t) {
        t.sx = t.x, t.sy = t.y
    }), t(points), points.forEach(function(t) {
        t.tx = t.x, t.ty = t.y
    }), timer = d3.timer(function(t) {
        var i = Math.min(1, ease(t / duration));
        points.forEach(function(t) {
            t.x = t.sx * (1 - i) + t.tx * i, t.y = t.sy * (1 - i) + t.ty * i
        }), draw(), 1 === i && (timer.stop(), currLayout = (currLayout + 1) % layouts.length, animate(layouts[currLayout]))
    })
}
var width = 600,
    height = 600,
    numPoints = 7e3,
    pointWidth = 4,
    pointMargin = 3,
    duration = 1500,
    ease = d3.easeCubic,
    timer, currLayout = 0,
    points = createPoints(numPoints, pointWidth, width, height),
    toGrid = function(t) {
        return gridLayout(t, pointWidth + pointMargin, width)
    },
    toSine = function(t) {
        return sineLayout(t, pointWidth + pointMargin, width, height)
    },
    toSpiral = function(t) {
        return spiralLayout(t, pointWidth + pointMargin, width, height)
    },
    toPhyllotaxis = function(t) {
        return phyllotaxisLayout(t, pointWidth + pointMargin, width / 2, height / 2)
    },
    layouts = [toSine, toPhyllotaxis, toSpiral, toPhyllotaxis, toGrid],
    screenScale = window.devicePixelRatio || 1,
    canvas = d3.select("body").append("canvas").attr("width", width * screenScale).attr("height", height * screenScale).style("width", width + "px").style("height", height + "px").on("click", function() {
        d3.select(".play-control").style("display", ""), timer.stop()
    });
canvas.node().getContext("2d").scale(screenScale, screenScale), toGrid(points), draw(), d3.select("body").append("div").attr("class", "play-control").text("PLAY").on("click", function() {
    animate(layouts[currLayout]), d3.select(this).style("display", "none")
});

function phyllotaxisLayout(points, pointWidth, xOffset, yOffset, iOffset) {
    if (xOffset === void 0) xOffset = 0;
    if (yOffset === void 0) yOffset = 0;
    if (iOffset === void 0) iOffset = 0;
    var theta = Math.PI * (3 - Math.sqrt(5));
    var pointRadius = pointWidth / 2;
    points.forEach(function(point, i) {
        var index = (i + iOffset) % points.length;
        var phylloX = pointRadius * Math.sqrt(index) * Math.cos(index * theta);
        var phylloY = pointRadius * Math.sqrt(index) * Math.sin(index * theta);
        point.x = xOffset + phylloX - pointRadius;
        point.y = yOffset + phylloY - pointRadius
    });
    return points
}

function gridLayout(points, pointWidth, gridWidth) {
    var pointHeight = pointWidth;
    var pointsPerRow = Math.floor(gridWidth / pointWidth);
    var numRows = points.length / pointsPerRow;
    points.forEach(function(point, i) {
        point.x = pointWidth * (i % pointsPerRow);
        point.y = pointHeight * Math.floor(i / pointsPerRow)
    });
    return points
}

function randomLayout(points, pointWidth, width, height) {
    points.forEach(function(point, i) {
        point.x = Math.random() * (width - pointWidth);
        point.y = Math.random() * (height - pointWidth)
    });
    return points
}

function sineLayout(points, pointWidth, width, height) {
    var amplitude = .3 * (height / 2);
    var yOffset = height / 2;
    var periods = 3;
    var yScale = d3.scaleLinear().domain([0, points.length - 1]).range([0, periods * 2 * Math.PI]);
    points.forEach(function(point, i) {
        point.x = i / points.length * (width - pointWidth);
        point.y = amplitude * Math.sin(yScale(i)) + yOffset
    });
    return points
}

function spiralLayout(points, pointWidth, width, height) {
    var amplitude = .3 * (height / 2);
    var xOffset = width / 2;
    var yOffset = height / 2;
    var periods = 20;
    var rScale = d3.scaleLinear().domain([0, points.length - 1]).range([0, Math.min(width / 2, height / 2) - pointWidth]);
    var thetaScale = d3.scaleLinear().domain([0, points.length - 1]).range([0, periods * 2 * Math.PI]);
    points.forEach(function(point, i) {
        point.x = rScale(i) * Math.cos(thetaScale(i)) + xOffset;
        point.y = rScale(i) * Math.sin(thetaScale(i)) + yOffset
    });
    return points
}

function createPoints(numPoints, pointWidth, width, height) {
    var colorScale = d3.scaleSequential(d3.interpolateViridis).domain([numPoints - 1, 0]);
    var points = d3.range(numPoints).map(function(id) {
        return {
            id: id,
            color: colorScale(id)
        }
    });
    return randomLayout(points, pointWidth, width, height)
}